package com.sebastianfox.food.controller;

//import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.sebastianfox.food.models.*;
import com.sebastianfox.food.repository.FriendshipRepository;
import com.sebastianfox.food.repository.InvitationRepository;
import com.sebastianfox.food.utils.Authenticator;
import com.sebastianfox.food.repository.UserRepository;
import org.json.JSONException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.*;

@SuppressWarnings("Duplicates")
@Controller    // This means that this class is a Controller
@RequestMapping(path = "/api/user")
// This means URL's start with /api (after Application path)
public class UserController {
    private final UserRepository userRepository;
    private final InvitationRepository invitationRepository;
    private final FriendshipRepository friendshipRepository;
    private Authenticator authenticator = new Authenticator();
    private ObjectMapper mapper = new ObjectMapper();

    // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    @Autowired
    public UserController(UserRepository userRepository, InvitationRepository invitationRepository, FriendshipRepository friendshipRepository) {
        this.userRepository = userRepository;
        this.invitationRepository = invitationRepository;
        this.friendshipRepository = friendshipRepository;
    }

    /*
     * register
     * login
     * fb login
     * fb register
     * get all user
     * get by
     * <p>
     * existing user request
     */

    /**
     * @param data JSON data from App
     * @return http response
     * @throws JSONException exception
     * @throws IOException   exception
     */
    @RequestMapping(path = "/authenticate", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> authenticate(@RequestBody HashMap<String, String> data) throws JSONException, IOException {
        User user = userRepository.findByEmail(data.get("email"));
        ObjectMapper mapper = new ObjectMapper();
        HashMap<String, Object> hashMap = new HashMap<>();

        // Failure at login (user not found or bad credentials)
        if (user == null || !authenticator.isExpectedPassword(data.get("password").toCharArray(), user.getSalt(), user.getPassword())) {
            // Object to JSON String
            String jsonString = mapper.writeValueAsString(hashMap);
            //User testUSer = mapper.readValue(jsonString, User.class);
            // Return to App
            return new ResponseEntity<>(jsonString, HttpStatus.UNAUTHORIZED);
        }

        // Successful login
        hashMap.put("user", user);
        // Object to JSON String
        String jsonString = mapper.writeValueAsString(hashMap);
        // Return to App
        return new ResponseEntity<>(jsonString, HttpStatus.OK);
    }

    /**
     * @param data JSON data from App
     * @return http response
     * @throws JSONException exception
     * @throws IOException   exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/reloadUser", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> reloadUser(@RequestBody HashMap<String, UUID> data) throws JSONException, IOException {

        ObjectMapper mapper = new ObjectMapper();
        HashMap<String, Object> hashMap = new HashMap<>();
        User user = userRepository.findById(data.get("id"));

        // Fail
        if (user == null) {
            // Object to JSON String
            String jsonString = mapper.writeValueAsString(hashMap);
            // Return to App
            return new ResponseEntity<>(jsonString, HttpStatus.NOT_FOUND);
        }

        // Success
        hashMap.put("user", user);
        // Object to JSON String
        String jsonString = mapper.writeValueAsString(hashMap);
        // Return to App
        return new ResponseEntity<>(jsonString, HttpStatus.OK);
    }

    /**
     * @param userData JSON data from App
     * @return http response
     * @throws JSONException exception
     * @throws IOException   exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/updateUser", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> updateUser(@RequestBody HashMap<String, User> userData) throws JSONException, IOException {
        ObjectMapper mapper = new ObjectMapper();
        HashMap<String, Object> hashMap = new HashMap<>();
        User appUser = userData.get("user");
        User user = userRepository.findById(appUser.getId());
        user.mergeDataFromOtherInstance(appUser);
        userRepository.save(user);

        // Successful register
        hashMap.put("user", user);
        // Object to JSON String
        String jsonString = mapper.writeValueAsString(hashMap);
        // Return to App
        return new ResponseEntity<>(jsonString, HttpStatus.OK);
    }

    /**
     * @param registerData JSON data from App
     * @return http response
     * @throws JSONException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/checkUsernameAvailability", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> checkUsernameAvailability(@RequestBody HashMap<String, String> registerData) throws JSONException {

        // Username already exist
        if (this.isUserNameAvailable(registerData.get("username"))) {
            return new ResponseEntity<>(null, HttpStatus.CONFLICT);
        }

        // Successful register
        // Return to App
        return new ResponseEntity<>(null, HttpStatus.OK);
    }

    /**
     * @param registerData JSON data from App
     * @return http response
     * @throws JSONException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/checkEmailAvailability", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> checkMail(@RequestBody HashMap<String, String> registerData) throws JSONException {

        if (this.isEmailAvailable(registerData.get("email"))) {
            return new ResponseEntity<>(null, HttpStatus.CONFLICT);
        }
        return new ResponseEntity<>(null, HttpStatus.OK);
    }

    /**
     * @param registerData JSON data from App
     * @return http response
     * @throws JSONException exception
     * @throws IOException   exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/registerUser", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> registerUser(@RequestBody HashMap<String, Object> registerData) throws JSONException, IOException {

        /*
         * Store values
         */
        String username = (String) registerData.get("userName");
        String mail = (String) registerData.get("email");
        String password = (String) registerData.get("password");

        ObjectMapper mapper = new ObjectMapper();
        HashMap<String, Object> hashMap = new HashMap<>();

        if (userRepository.findByUserName(username) != null) {
            // Object to JSON String
            return new ResponseEntity<>(null, HttpStatus.CONFLICT);
        }
        if (userRepository.findByEmail(mail) != null) {
            return new ResponseEntity<>(null, HttpStatus.CONFLICT);
        }
        // Create and safe new user
        User user = new User();
        user.setUserName(username);
        user.setEmail(mail);
        user.setSalt(authenticator.getNextSalt());
        user.setPassword(authenticator.hash(password.toCharArray(), user.getSalt()));
        userRepository.save(user);

        Iterable<Invitation> invitations = invitationRepository.findByEmail(mail);
        for (Invitation invitation : invitations) {
            invitation.setInvited(user);
            invitationRepository.save(invitation);
        }

        // Successful register
        hashMap.put("user", user);
        // Object to JSON String
        String jsonString = mapper.writeValueAsString(hashMap);
        // Return to App
        return new ResponseEntity<>(jsonString, HttpStatus.CREATED);
    }

    /**
     * @param loginData JSON data from App
     * @return http response
     * @throws JSONException exception
     * @throws IOException   exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/facebookLogin", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> facebookLogin(@RequestBody HashMap<String, Object> loginData) throws JSONException, IOException {
        ObjectMapper mapper = new ObjectMapper();
        HashMap<String, Object> hashMap = new HashMap<>();
        User requestedUser = (User) loginData.get("user");
        User facebookUser = userRepository.findByFacebookAccountId(requestedUser.getFacebookAccountId());

        // If user does not exist, create it
        if (facebookUser == null) {
            userRepository.save(requestedUser);

            Iterable<Invitation> invitations = invitationRepository.findByEmail(requestedUser.getEmail());
            for (Invitation invitation : invitations) {
                invitation.setInvited(requestedUser);
                invitationRepository.save(invitation);
            }


            hashMap.put("user", requestedUser);
            // Object to JSON String
            String jsonString = mapper.writeValueAsString(hashMap);
            return new ResponseEntity<>(jsonString, HttpStatus.CREATED);
        }

        // User already exists and is foud in database
        hashMap.put("user", facebookUser);
        // Object to JSON String
        String jsonString = mapper.writeValueAsString(hashMap);
        // Return to App
        return new ResponseEntity<>(jsonString, HttpStatus.OK);
    }

    /**
     * @param data/ JSON data from App
     * @return http response
     * @throws JSONException exception
     * @throws IOException   exception
     */
    @RequestMapping(path = "/findByUsername", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> findByUsername(@RequestBody HashMap<String, String> data) throws JSONException, IOException {

        // create hashmap for response
        HashMap<String, Object> responseHash = new HashMap<>();

        // get username from request
        String requestedUserName = data.get("userName");

        // check if username belongs to an existing user
        if (this.isUserNameAvailable(requestedUserName)){

            // no user with requested name found, return back to app
           return new ResponseEntity<>(null, HttpStatus.BAD_REQUEST);
        }

        // Select user from database
        User requestedUser = this.findByUserName(requestedUserName);

        // collect/prepare response data
        responseHash.put("user", requestedUser);

        // object to JSON String
        String jsonString = mapper.writeValueAsString(responseHash);

        // Return to app
        return new ResponseEntity<>(jsonString, HttpStatus.OK);
    }

    /**
     * @param data JSON data from App
     * @return http response
     * @throws JSONException exception
     * @throws IOException   exception
     */
    @RequestMapping(path = "/findByMail", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> findByMail(@RequestBody HashMap<String, String> data) throws JSONException, IOException {

        // create hashmap for response
        HashMap<String, Object> responseHash = new HashMap<>();

        // get email from request
        String requestedEmail = data.get("email");

        // check if username belongs to an existing user
        if (this.isEmailAvailable(requestedEmail)){

            // no user with requested name found, return back to app
            return new ResponseEntity<>(null, HttpStatus.BAD_REQUEST);
        }

        // Select user from database
        User requestedUser = this.findByEmail(requestedEmail);

        // collect/prepare response data
        responseHash.put("user", requestedUser);

        // object to JSON String
        String jsonString = mapper.writeValueAsString(responseHash);

        // Return to app
        return new ResponseEntity<>(jsonString, HttpStatus.OK);
    }

    /*
        Friendship handling
     */

    /**
     * @param data JSON data from App
     * @return http response
     * @throws JSONException exception
     * @throws IOException   exception
     */
    @RequestMapping(path = "/createAndAcceptFriendRequest", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> createAndAcceptFriendRequest(@RequestBody HashMap<String, UUID> data) throws JSONException, IOException {

        // create hashmap for response
        HashMap<String, Object> responseHash = new HashMap<>();

        // get user_id from request
        User user = userRepository.findById(data.get("user_id"));

        // get friend_id from request
        User friend = userRepository.findById(data.get("friend_id"));

        // create friendship or accept friendship request (if existing) user -> friend
        Friendship friendship = user.createAndAcceptFriendship(friend);

        // save friendship
        friendshipRepository.save(friendship);

        // collect/prepare response data (return user with current friendships)
        responseHash.put("user", user);

        // Object to JSON String
        String jsonString = mapper.writeValueAsString(responseHash);

        // Return to app
        return new ResponseEntity<>(jsonString, HttpStatus.OK);
    }

    /**
     * @param data JSON data from App
     * @return http response
     * @throws JSONException exception
     * @throws IOException   exception
     */
    @RequestMapping(path = "/declineAndDeleteFriendship", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> declineAndDeleteFriendship(@RequestBody HashMap<String, UUID> data) throws JSONException, IOException {

        // create hashmap for response
        HashMap<String, Object> responseHash = new HashMap<>();

        // get user_id from request
        User user = userRepository.findById(data.get("user_id"));

        // get friend_id from request
        User friend = userRepository.findById(data.get("friend_id"));

        // fremove friendship from friendship lists (user and friend)
        Friendship friendship = user.declineAndDeleteFriendship(friend);

        // remove freindship from database
        friendshipRepository.delete(friendship);

        // collect/prepare response data (return user with current friendships)
        responseHash.put("user", user);

        // Object to JSON String
        String jsonString = mapper.writeValueAsString(responseHash);

        // Return to app
        return new ResponseEntity<>(jsonString, HttpStatus.OK);
    }

    /**
     * @param email JSON data from App
     * @return boolean
     */
    private boolean isEmailAvailable(String email) {

        // Mail already exist
        return userRepository.findByEmail(email) == null;
    }

    /**
     * @param userName JSON data from App
     * @return boolean
     */
    private boolean isUserNameAvailable(String userName) {

        // UserName already exist
        return userRepository.findByUserName(userName) == null;
    }
    /**
     * @param email JSON data from App
     * @return boolean
     */
    private User findByEmail(String email) {

        // Get user by its (distinct) email address
        return userRepository.findByEmail(email);
    }

    /**
     * @param userName JSON data from App
     * @return boolean
     */
    private User findByUserName(String userName) {

        // Get user by its (distinct) userName
        return userRepository.findByUserName(userName);
    }

    /**
     * @param data JSON data from App
     * @return http response
     * @throws JSONException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/updateUserEmail", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> updateUserEmail(@RequestBody HashMap<String,HashMap> data) throws JSONException, IOException {

        // create hashmap for response
        HashMap<String, Object> responseHash = new HashMap<>();

        // exclude data from hashmap
        HashMap dataHashMap = data.get("data");

        // create JSON string from sub hashmap with user data
        String userJsonString = mapper.writeValueAsString(dataHashMap.get("user"));

        // transform JSON to User
        User user = mapper.readValue(userJsonString, User.class);

        // get user from db
        User dbUser = userRepository.findById(user.getId());

        // get new email from request and set it on database user
        if (isEmailAvailable(user.getEmail())) {

            // set new email address
            dbUser.setEmail(user.getEmail());

            // sace user
            userRepository.save(dbUser);

            // collect/prepare response data (return user with current friendships)
            responseHash.put("user", dbUser);

            // Object to JSON String
            String jsonString = mapper.writeValueAsString(responseHash);

            // Return to app (successful)
            return new ResponseEntity<>(jsonString, HttpStatus.OK);
        }

        // Object to JSON String
        responseHash.put("user", dbUser);

        // Object to JSON String
        String jsonString = mapper.writeValueAsString(responseHash);

        // Return to app (not successful)
        return new ResponseEntity<>(jsonString, HttpStatus.CONFLICT);
    }

}
