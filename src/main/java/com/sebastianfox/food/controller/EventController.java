package com.sebastianfox.food.controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.sebastianfox.food.models.Event;
import com.sebastianfox.food.models.Location;
import com.sebastianfox.food.models.User;
import com.sebastianfox.food.repository.Event.EventRepository;
import com.sebastianfox.food.repository.Location.LocationRepository;
import com.sebastianfox.food.repository.User.UserRepository;
import com.sebastianfox.food.services.EventService;
import org.json.JSONException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import javax.persistence.*;
import java.io.IOException;
import java.util.*;

@SuppressWarnings("unused")
@Controller    // This means that this class is a Controller
@PersistenceContext
@RequestMapping(path = "/api/event") // This means URL's start with /api (after Application path)
public class EventController {

    private final EventRepository eventRepository;
    private final UserRepository userRepository;
    private final LocationRepository locationRepository;
    private ObjectMapper mapper = new ObjectMapper();
    private EventService eventService = new EventService();

    // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    @Autowired
    public EventController(EventRepository eventRepository, UserRepository userRepository,
                           LocationRepository locationRepository) {
        this.eventRepository = eventRepository;
        this.userRepository = userRepository;
        this.locationRepository = locationRepository;
    }

    /**
     *
     * @param localeData JSON data from App
     * @throws JSONException exception
     * @throws IOException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/loadAllEvents", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> loadAllEvents(@RequestBody HashMap<String, String> localeData)
            throws JSONException, IOException {

        // load all events
        Iterable<Event> events = eventRepository.findAll();

        // Return to App
        return new ResponseEntity<>(createResposneJson("events", events), HttpStatus.ACCEPTED);
    }

    /**
     *
     * @param localeData JSON data from App
     * @throws JSONException exception
     * @throws IOException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/loadAllNotDeletedEvents", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> loadAllNotDeletedEvents(@RequestBody HashMap<String, String> localeData)
            throws JSONException, IOException {

        // load all not deleted events
        Iterable<Event> events = eventRepository.findAllByDeletedIsFalse();

        // Return to App
        return new ResponseEntity<>(createResposneJson("events", events), HttpStatus.ACCEPTED);
    }

    /**
     *
     * @param data JSON data from App
     * @throws JSONException exception
     * @throws IOException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/loadEventsByUserId", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> loadEventsByUserId(@RequestBody HashMap<String, Object> data)
            throws JSONException, IOException {

        UUID userId = mapper.convertValue(data.get("user_id"), UUID.class);
        User user = userRepository.findById(userId);

        // check if user is available in database
        if (user == null) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }

        // check it getEvents is not null
        if (user.getEvents() == null) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }

        // Return to App
        return new ResponseEntity<>(createResposneJson("events", user.getEvents()), HttpStatus.ACCEPTED);
    }

    /**
     *
     * @param data JSON data from App
     * @throws JSONException exception
     * @throws IOException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/reloadEvent", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> reloadEvent(@RequestBody HashMap<String, Object> data)
            throws JSONException, IOException {

        // Get Data
        UUID uuid = mapper.convertValue(data.get("id"), UUID.class);
        Event event = eventRepository.findById(uuid);

        // Check if event is available in database
        if (event == null){
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }

        // Return to App
        return new ResponseEntity<>(createResposneJson("event", event), HttpStatus.ACCEPTED);
    }

    /**
     *
     * @param data JSON data from App
     * @throws JSONException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/createOrUpdateEventByObject", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> createOrUpdateEventByObject(@RequestBody HashMap<String, Object> data)
            throws JSONException, IOException {

        // Declare variables
        Event dbEvent;

        // convert determined data into correct types
        HashMap ids = mapper.convertValue(data.get("ids"), HashMap.class);
        Event appEvent = mapper.convertValue(data.get("event"), Event.class);

        // check if all conditions are given to save or update an event at all
        if (appEvent == null ||
                appEvent.getLocation() == null ||
                appEvent.getLocation().getLangitude() == null ||
                appEvent.getLocation().getLongitude() == null) {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

        // check if location (langitude/longitude) within event already exists, if so, re-use existing location
        Location location = locationRepository.findByLangitudeIsAndLongitudeIs(
                appEvent.getLocation().getLangitude(), appEvent.getLocation().getLongitude());
        if (location != null) {
            appEvent.setLocation(location);
            locationRepository.save(location);
        } else {
            locationRepository.save(appEvent.getLocation());
        }

        // check if event already exists (persist new instance or update existing one)
        if (appEvent.getId() != null) {
            dbEvent = eventRepository.findById(appEvent.getId());
            dbEvent.mergeDataFromOtherInstance(appEvent);
        } else {
            dbEvent = appEvent;
            UUID uuid = mapper.convertValue(ids.get("user_id"), UUID.class);
            User dbUser = userRepository.findById(uuid);
            dbEvent.setOwner(dbUser);
        }

        // save event
        eventRepository.save(dbEvent);

        // Return to app
        return new ResponseEntity<>(createResposneJson("event", dbEvent), HttpStatus.CREATED);
    }

    /**
     *
     * @param data JSON data from App
     * @throws JSONException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/attendToEvent", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> attendToEvent(@RequestBody HashMap<String, Object> data)
            throws JSONException, JsonProcessingException {

        // check if necessary parameters available
        if (data.get("user_id") == null || data.get("event_id") == null){
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

        // Find event by given id
        UUID eventId = mapper.convertValue(data.get("event_id"), UUID.class);
        Event event = eventRepository.findById(eventId);

        // Find user of event by given id
        UUID userId = mapper.convertValue(data.get("user_id"), UUID.class);
        User user = userRepository.findById(userId);

        // check if user and event are both available
        if (user == null || event == null) {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

        // // add interested by EventService
        eventService.attendToEvent(event, user);

        // save event (merges the user as well)
        eventRepository.save(event);

        // Return to App
        return new ResponseEntity<>(createResposneJson("event", event), HttpStatus.ACCEPTED);
    }

    /**
     *
     * @param data JSON data from App
     * @throws JSONException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/acceptInterested", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> acceptInterested(@RequestBody HashMap<String, Object> data)
            throws JSONException, JsonProcessingException {

        if (data.get("user_id") == null || data.get("event_id") == null){
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

        // Find event by given id
        UUID eventId = mapper.convertValue(data.get("event_id"), UUID.class);
        Event event = eventRepository.findById(eventId);

        // Find user of event by given id
        UUID userId = mapper.convertValue(data.get("user_id"), UUID.class);
        User user = userRepository.findById(userId);

        // check if user and event are both available
        if (user == null || event == null) {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

        // accept interested by EventService
        eventService.acceptInterested(event, user);

        // save event (merges the user as well)
        eventRepository.save(event);

        // Return to App
        return new ResponseEntity<>(createResposneJson("event", event), HttpStatus.ACCEPTED);
    }

    /**
     *
     * @param data JSON data from App
     * @throws JSONException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/declineInterested", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> declineInterested(@RequestBody HashMap<String, Object> data)
            throws JSONException, JsonProcessingException {

        if (data.get("user_id") == null || data.get("event_id") == null){
            return new ResponseEntity<>(null, HttpStatus.BAD_REQUEST);
        }

        // Find event by given id
        UUID eventId = mapper.convertValue(data.get("event_id"), UUID.class);
        Event event = eventRepository.findById(eventId);

        // Find user of event by given id
        UUID userId = mapper.convertValue(data.get("user_id"), UUID.class);
        User user = userRepository.findById(userId);

        // check if user and event are both available
        if (user == null || event == null) {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

        // decline interested by EventService
        eventService.declineInterested(event, user);

        // save event (merges the user as well)
        eventRepository.save(event);

        // Return to App
        return new ResponseEntity<>(createResposneJson("event", event), HttpStatus.ACCEPTED);
    }

    /**
     *
     * @param data JSON data from App
     * @throws JSONException exception
     */
    @SuppressWarnings("Duplicates")
    @RequestMapping(path = "/deleteEvent", method = RequestMethod.POST, consumes = {"application/json"})
    public ResponseEntity<Object> deleteEvent(@RequestBody HashMap<String, Object> data)
            throws JSONException {

        // Get Data
        UUID id = mapper.convertValue(data.get("id"), UUID.class);

        Event event = eventRepository.findById(id);

        // Check if event is available in database
        if (event == null){
            return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
        }

        eventService.deleteEvent(event);
        eventRepository.save(event);

        // Return to App
        return new ResponseEntity<>(HttpStatus.OK);
    }

    /**
     *
     * @param key for Response HashMap
     * @param value for Repsonse HashMao
     * @return String with ResponseJSON
     * @throws JSONException exceptionhandling
     * @throws JsonProcessingException exceptionhandling
     */
    private String createResposneJson(String key, Object value) throws JSONException, JsonProcessingException {
        HashMap<String,Object> responseHash = new HashMap<>();
        responseHash.put(key, value);
        return mapper.writeValueAsString(responseHash);
    }
}